# Copyright (c) Quentin DASSIBAT <qdassibat@gmail.com>

#Ecole des Mines de Saint-Etienne (EMSE)
#Ecole Nationale des Travaux Publics de l'Etat (ENTPE)
#Ecole Urbaine de Lyon (EUL)

# Source Code License (GPLv3)

#This software and its source code are licensed under the GNU General Public License (GPL), version 3.0 or later. See the LICENSE file for details.

# Output License (CC BY 4.0)

#Any outputs generated by this software, such as data files, images, or other results, are licensed under the Creative Commons Attribution 4.0 International License (CC BY 4.0).

#You are free to share, adapt, and use these outputs, provided you give appropriate credit to the original author(s). See the LICENSE file for details.

# For details about each license, please refer to:
#- GNU General Public License (GPL), version 3.0: https://www.gnu.org/licenses/gpl-3.0.html
#- Creative Commons Attribution 4.0 International License (CC BY 4.0): http://creativecommons.org/licenses/by/4.0/ 

##################
# Set parameters #
##################

#Import libraries
import geopandas as gpd
import matplotlib.pyplot as plt
import relio
import shapely as shp

#Set path and working directories
wd = os.getcwd()
InputModelDirectory = f"{wd}/MODEL_inputs"
hydrographicDirectory = f"{wd}/HYDRO_inputs"
tmpDirectory = f"{wd}/tmp"
if os.path.isdir(tmpDirectory) is False:
    os.mkdir(f"{wd}/tmp")
else:
    pass
outputDirectory = f"{wd}/RESAMPLINGoutputs"
if os.path.isdir(outputDirectory) is False:
    os.mkdir(f"{wd}/RESAMPLINGoutputs")
else:
    pass

#Set parameters
EPSG = 4326


##################
# Execute module #
##################


#Determine channels flowing inside out the envelope
envelopeNumber = 5
e0 = gpd.read_file(f"{hydrographicDirectory}/envelope{str(envelopeNumber)}.gpkg")
channels = gpd.read_file("/home/q.dassibat/python_proj/env3/modules/HYDRO_inputs/cours_eau_topage_epsg4326.gpkg")
join = gpd.sjoin(left_df=e0, right_df=channels, how="left", predicate="intersects")
channels_ids = list(set(join['gid']))
channels_intersect_e0 = channels.loc[channels['gid'].isin(channels_ids)]
channels_inner_e0 = channels_intersect_e0.clip(e0,keep_geom_type=True)
channels_outer_e0 = channels_intersect_e0.symmetric_difference(channels_inner_e0)

tmp = gpd.GeoDataFrame(channels_outer_e0,columns=['geometry'])
mask = ~tmp['geometry'].is_empty
xtended_channels = tmp.loc[mask]

#Identify biggest channels through their relative length
#Create uid column for channels
xtended_channels.reset_index(drop=False,inplace=True)
xtended_channels.loc[:,'channel_uid'] = xtended_channels.loc[:,'index']
xtended_channels.drop(labels='index',axis=1,inplace=True)
#Compute linestring length (first convert CRS to meter_CRS, then go back to former CRS)
xtended_channels.to_crs(2154,inplace=True)
xtended_channels['length'] = xtended_channels['geometry'].length
xtended_channels.to_crs(EPSG,inplace=True)
#xtended_channels.to_file()



#Optionnaly identify relevant percentiles
percentile = 0.9
toplot = xtended_channels.drop(labels='geometry',axis=1)
toplot.sort_values(by=['length'],ascending=False,inplace=True)
toplot.reset_index(drop=True,inplace=True)
toplot['length_percent'] = toplot['length'] / toplot['length'].sum()
toplot['cum_length_percent'] = toplot['length_percent'].cumsum()
mask = toplot['cum_length_percent'] <= percentile
tmp = toplot.loc[mask]
#--> with only the 6 biggest channels out of 174, 70% of total length inflowing or outflowing is captured; 80% with the first 13; and 90% with the first 36. 
#Convert identified channels back to geodataframe
xtended_channels.drop(labels='length',axis=1,inplace=True)
join = xtended_channels.merge(tmp, how='inner', on='channel_uid')
join.to_file(f"{hydrographicDirectory}/envelope{str(envelopeNumber)}_xtended_channels_{str(percentile*100)}percent.gpkg")



#Optionaly count how many channels there are that still flow inside out 

gdf = join.copy()

#Such channels are those that have been cut by the above clip operation: the result is such that segments for a common uid cannot be merged in a single shapely.linestring 
#but will keep resulting as a shapely.multilinestring

multiline_list = list(gdf['geometry'])
singleline_list = []
for geom in multiline_list:
    singleline_list.append(shp.ops.linemerge(geom))

geom_type = ["MultiLineString" if type(x) == shp.geometry.multilinestring.MultiLineString else "LineString" for x in singleline_list]
gdf.loc[:,'geom_type'] = geom_type
inoutflow = gdf.loc[gdf['geom_type']=="MultiLineString"]

print(f"With envelope{str(envelopeNumber)}, {str(len(inoutflow)} channels are flowing inside out the envelope")

inoutflow.to_file(f"{hydrographicDirectory}/envelope{str(envelopeNumber)}_xtended_channels_{str(percentile*100)}percent_FlowingInOut.gpkg")
del gdf



#Bunch of code to compute length of upstream sections of still inside out flowing channels 
#Set UseBunch to True and change file paths

UseBunch = False

if UseBunch is True:

    df1 = gpd.read_file(f"{hydrographicDirectory}/rhoneamont.gpkg")
    df2 = gpd.read_file(f"{hydrographicDirectory}/loireamont.gpkg")
    df3 = gpd.read_file(f"{hydrographicDirectory}/allieramont.gpkg")
    df4 = gpd.read_file(f"{hydrographicDirectory}/tuyereamont.gpkg")
    df = pd.concat([df1,df2,df3,df4])
    gdf = gpd.GeoDataFrame(df, crs=f"EPSG:{str(EPSG)}")
    gdf = gdf.set_geometry('geometry')
    gdf.to_crs(2154,inplace=True)
    gdf['upstream_length'] = gdf['geometry'].length
    gdf.to_crs(EPSG,inplace=True)
    gdf.to_file(f"{hydrographicDirectory}/envelope{str(envelopeNumber)}_xtended_channels_{str(percentile*100)}percent_FlowingInOutUpstreamSections.gpkg")

else:
    pass
