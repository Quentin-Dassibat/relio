# Copyright (c) Quentin DASSIBAT <qdassibat@gmail.com>

#Ecole des Mines de Saint-Etienne (EMSE)
#Ecole Nationale des Travaux Publics de l'Etat (ENTPE)
#Ecole Urbaine de Lyon (EUL)

# Source Code License (GPLv3)

#This software and its source code are licensed under the GNU General Public License (GPL), version 3.0 or later. See the LICENSE file for details.

# Output License (CC BY 4.0)

#Any outputs generated by this software, such as data files, images, or other results, are licensed under the Creative Commons Attribution 4.0 International License (CC BY 4.0).

#You are free to share, adapt, and use these outputs, provided you give appropriate credit to the original author(s). See the LICENSE file for details.

# For details about each license, please refer to:
#- GNU General Public License (GPL), version 3.0: https://www.gnu.org/licenses/gpl-3.0.html
#- Creative Commons Attribution 4.0 International License (CC BY 4.0): http://creativecommons.org/licenses/by/4.0/ 


##################
# Set parameters #
##################

#Import libraries
import os
import relio
import numpy as np
import datetime
import pandas as pd
import geopandas as gpd
import shapely
from osgeo import gdal
gdal.UseExceptions()

#Set path and working directories
wd = os.getcwd()
InputModelDirectory = f"{wd}/MODEL_inputs"
hydrographicDirectory = f"{wd}/HYDRO_inputs"
tmpDirectory = f"{wd}/tmp"
if os.path.isdir(tmpDirectory) is False:
    os.mkdir(f"{wd}/tmp")
else:
    pass
outputDirectory = f"{wd}/RESAMPLINGoutputs"
if os.path.isdir(outputDirectory) is False:
    os.mkdir(f"{wd}/RESAMPLINGoutputs")
else:
    pass

#Set parameters
EPSG = 4326
epsilonAccuflux = 1e3
envelopeNumber = 5
DEM = f"{hydrographicDirectory}/DEMx_SRTM30_wgs84_envelope5.tif"
AoI = f"{hydrographicDirectory}/envelope{str(envelopeNumber)}.gpkg"

##################
# Execute module #
##################
globstart = datetime.datetime.now()

print("Extract channels from topographic layer that intersect the enveloppe, then explode multilinestrings to linestrings")
channels = gpd.read_file("/home/q.dassibat/python_proj/env3/modules/HYDRO_inputs/cours_eau_topage_epsg4326.gpkg")
envelope = gpd.read_file(AoI)
channels_clip = channels.clip(envelope,keep_geom_type=True)
channels_exploded = channels_clip.explode(ignore_index=True) #multilinestrings to linestings

print("Load mask raster after conversion to metric coordniate system, to get geoT properties")
mask = gdal.Open(DEM)
upx, xres, xskew, upy, yskew, yres = mask.GetGeoTransform()
mask = None

print("Generate points along linestrings at the regular spacing of the mask's resolution")
distance_delta = xres
line_list = list(channels_exploded['geometry'])
points_list = []
for line in line_list:
    distances = np.arange(0, line.length, distance_delta)
    points = [line.interpolate(distance) for distance in distances]
    for p in points:
        points_list.append(p)

print("Export points as geodataframe")
frames = {'z_field':[z/z for z in list(np.arange(1,len(points_list)+1,1))], #z_field is made of value 1
          'geometry':[point for point in points_list]
         }
df = pd.DataFrame(frames)
gdf_points = gpd.GeoDataFrame(df, crs=f"EPSG:{str(EPSG)}")
gdf_points= gdf_points.set_geometry('geometry')
del df

print("Generate a nearest-neighbour raster based on points layer") 
#1st convert the mask raster to a gdf
dic = relio.extract_cellsValues(DEM)
gdf_raster = relio.cells_to_points(dic,EPSG)
gdf_raster['id_mask'] = [id for id in list(np.arange(0,len(gdf),1))]
gdf_raster.drop(labels=['id','values'],axis=1,inplace=True)
#2nd make an inner spatial join between that gdf and the above created points layer
join = gpd.sjoin_nearest(gdf_points,gdf_raster,how='left',lsuffix='points', rsuffix='raster')
#3rd make an attribute outer join to go back the shape of mask raster
merge = gdf_raster.merge(join,left_on='id_raster',right_on='id_raster',how='left',suffixes=('_points', '_raster'))
#4th use relio.points_to_raster() 
dst = f"{hydrographicDirectory}/channels_density_envelope{str(envelopeNumber)}.tif"
relio.points_to_raster(merge, 'z_field', DEM, dst, EPSG)

print("Count no-NaN values in the 'z_field' column and report it against the total length to get the channels network densisty ratio") 
tmp = merge.loc[~merge['z_field'].isna()]
NbNoNaN = len(tmp)
ref_density = NbNoNaN/len(merge)
print("reference density", ref_density)











