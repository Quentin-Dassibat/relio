# Copyright (c) Quentin DASSIBAT <qdassibat@gmail.com>

#Ecole des Mines de Saint-Etienne (EMSE)
#Ecole Nationale des Travaux Publics de l'Etat (ENTPE)
#Ecole Urbaine de Lyon (EUL)

# Source Code License (GPLv3)

#This software and its source code are licensed under the GNU General Public License (GPL), version 3.0 or later. See the LICENSE file for details.

# Output License (CC BY 4.0)

#Any outputs generated by this software, such as data files, images, or other results, are licensed under the Creative Commons Attribution 4.0 International License (CC BY 4.0).

#You are free to share, adapt, and use these outputs, provided you give appropriate credit to the original author(s). See the LICENSE file for details.

# For details about each license, please refer to:
#- GNU General Public License (GPL), version 3.0: https://www.gnu.org/licenses/gpl-3.0.html
#- Creative Commons Attribution 4.0 International License (CC BY 4.0): http://creativecommons.org/licenses/by/4.0/ 


##################
# Set parameters #
##################

#Import libraries
import os
import relio
import numpy as np
import pandas as pd
import geopandas as gpd
import datetime

#Set path and working directories

wd = os.getcwd()
InputModelDirectory = f"{wd}/MODEL_inputs"
hydrographicDirectory = f"{wd}/HYDRO_inputs"

tmpDirectory = f"{wd}/tmp"
if os.path.isdir(tmpDirectory) is False:
    os.mkdir(f"{wd}/tmp")
else:
    pass

outputDirectory = f"{wd}/RESAMPLINGoutputs"
if os.path.isdir(outputDirectory) is False:
    os.mkdir(f"{wd}/RESAMPLINGoutputs")
else:
    pass


#Set parameters
EPSG = 4326
epsilonAccuflux = 1e3
epsilonOutlet = 1e3
modelRun = "DIST"
bandNumber = 1


##################
# Execute module #
##################
globstart = datetime.datetime.now()

print("Extract edge cells coordinates in a WBM raster (already clipped to AoI)")

start = datetime.datetime.now()
src = f"{InputModelDirectory}/WBM_TerraClimate_OUTPUTQ_{str(modelRun)}_mLTM_2000-2020_band{str(bandNumber)}_clip.tif"
WBMedges = relio.extract_edges(src) 
print("Elapsed time: ", datetime.datetime.now()-start)
del src

gdfOutletsValues_list = []
gdfOutletsCodes_list = []

print("Clip flow direction map with WBMedges bbox and extract edge outlets of each tile")
start = datetime.datetime.now()

for j in range(len(WBMedges['coordinates'])):
    
    print("WBMcell",j)
    
    extent = WBMedges['coordinates'][j]
    print("Clip flowdirection")
    src = f"{hydrographicDirectory}/DEMx_SRTM30_wgs84_pcraster_flowdir.tif"
    dst = f"{tmpDirectory}/DEMx_SRTM30_wgs84_pcraster_flowdir_clip{str(j)}.tif"
    relio.clip(src,dst,EPSG,extent)
    del src, dst
    
    print("Extract edge outlets (and those outlets that for some reason do not locate on the edges)")
    src = f"{tmpDirectory}/DEMx_SRTM30_wgs84_pcraster_flowdir_clip{str(j)}.tif"
    dst = f"{tmpDirectory}/DEMx_SRTM30_wgs84_edgeOutlets_clip{str(j)}.tif"
    relio.extract_edge_outlets(src,dst,EPSG)
    del src, dst
    
    print("Create gdfOutletsCodes")
    src = f"{tmpDirectory}/DEMx_SRTM30_wgs84_pcraster_flowdir_clip{str(j)}.tif" #scalar raster
    dic = relio.extract_cellsValues(src)
    outletsAll = relio.cells_to_polygons(dic,EPSG)
    del src, dic
    src = f"{tmpDirectory}/DEMx_SRTM30_wgs84_edgeOutlets_clip{str(j)}.tif" #boolean raster
    dic = relio.extract_cellsValues(src)
    outletsEdges = relio.cells_to_polygons(dic,EPSG)
    del src, dic
    gdfOutletsCodes = outletsEdges.copy()
    gdfOutletsCodes['outletCode'] = outletsAll['values']*outletsEdges['values'] #scalar*boolean=scalar
    gdfOutletsCodes.drop(['values'],axis=1,inplace=True)
    gdfOutletsCodes_list.append(gdfOutletsCodes)
    del gdfOutletsCodes
    
    print("Clip accuflux")
    src = f"{hydrographicDirectory}/DEMx_SRTM30_wgs84_pcraster_accuflux_sup{str(epsilonAccuflux)}.tif"
    dst = f"{tmpDirectory}/DEMx_SRTM30_wgs84_pcraster_accuflux_sup{str(epsilonAccuflux)}_clip{str(j)}.tif"
    relio.clip(src,dst,EPSG,extent)
    del src, dst
    
    print("Retrieve only significant outlets (greater than epsilonAccuflux and epsilonOutlet)")
    src = f"{tmpDirectory}/DEMx_SRTM30_wgs84_pcraster_accuflux_sup{str(epsilonAccuflux)}_clip{str(j)}.tif"
    msk = f"{tmpDirectory}/DEMx_SRTM30_wgs84_edgeOutlets_clip{str(j)}.tif"
    dst = f"{tmpDirectory}/DEMx_SRTM30_wgs84_edgeOutlets_sup{str(epsilonOutlet)}_clip{str(j)}.tif"
    relio.significant_outlets(src,msk,dst,EPSG,epsilonOutlet)
    del src, dst
    
    print("Export as geoDataFrame")
    src = f"{tmpDirectory}/DEMx_SRTM30_wgs84_edgeOutlets_sup{str(epsilonOutlet)}_clip{str(j)}.tif"
    dic = relio.extract_cellsValues(src)
    gdfOutletsValues = relio.cells_to_polygons(dic,EPSG)
    gdfOutletsValues_list.append(gdfOutletsValues)    
    del gdfOutletsValues, src, dic

print("Elapsed time: ", datetime.datetime.now()-start)

print("Concatenate geoDataFrames")
gdfOutletsValues = pd.concat(gdfOutletsValues_list)
gdfOutletsCodes = pd.concat(gdfOutletsCodes_list)
gdfOutletsValues.reset_index(drop=True,inplace=True)
gdfOutletsCodes.reset_index(drop=True,inplace=True)

print("Add outletCode column")
codes = gdfOutletsCodes['outletCode']
gdfOutletsValues['outletCode'] = codes

print("Mark outlets as flowing out of the AoI or not + change 'value' column label to 'AccufluxValues'")
gdfOutletsValues['OUTflow'] = np.where(gdfOutletsValues['outletCode']==np.float32(5), "True", "False")
gdfOutletsValues['AccufluxValues'] = gdfOutletsValues['values']
gdfOutletsValues.drop(['values'],axis=1,inplace=True)

print("Drop NaN in colomn 'AccufluxValues' to lighten dataframe + drop duplicates in 'id' column")
gdfOutletsValues.dropna(subset='AccufluxValues',axis=0,inplace=True)
gdfOutletsValues.drop_duplicates(subset=['id'],inplace=True)
gdfOutletsValues.reset_index(drop=True,inplace=True)

print("Fiona cannot interpret Python's tuples contained in 'id_outlets' and 'id_wbm' so turn them to strings in new columns 'uid_outlets' and 'uid_wbm'")
df = gdfOutletsValues.copy()
tup = list(df['id'])
string = []
for elem in tup:
    y,x = elem
    string.append(f"({str(y)}"+','+f"{str(x)})")
df.drop(['id'],axis=1,inplace=True)
df.loc[:,'id'] = string
df.reset_index(drop=True,inplace=True)

print("Convert outlet location geodataframe from polygons to points") 
df.to_crs(crs=f"EPSG:{str(EPSG)}",inplace=True)
df["centroid"] = df["geometry"].centroid
df.drop(['geometry'],axis=1,inplace=True)
df.loc[:,'geometry'] = df.loc[:,'centroid']
df.drop(['centroid'],axis=1,inplace=True)
df.set_geometry("geometry",crs=f"EPSG:{str(EPSG)}",inplace=True)



print("Write layer gdfOutletsValues to disk")
df.to_file(f"{outputDirectory}/OutletsLocations_sup{str(epsilonOutlet)}_mod{modelRun}_band{str(bandNumber)}_points.gpkg")

print("Total Elapsed Time: ", datetime.datetime.now()-globstart)

with open(f"{tmpDirectory}/log.txt", 'a') as file:
    file.write(f"OUTLETSlocation.py Elapsed Time: {str(datetime.datetime.now()-globstart)}\n")